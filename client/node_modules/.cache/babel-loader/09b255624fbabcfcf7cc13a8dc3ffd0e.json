{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridLogger } from '../../utils/useGridLogger';\nimport { gridRowCountSelector, gridRowsLookupSelector, gridRowTreeSelector, gridRowIdsSelector, gridRowGroupingNameSelector } from './gridRowsSelector';\nimport { GridSignature, useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { gridSortedRowIdsSelector } from '../sorting/gridSortingSelector';\nimport { gridFilteredRowsLookupSelector } from '../filter/gridFilterSelector';\nimport { getTreeNodeDescendants, createRowsInternalCache, getRowsStateFromCache, getRowIdFromRowModel } from './gridRowsUtils';\nimport { useGridRegisterPipeApplier } from '../../core/pipeProcessing';\nexport const rowsStateInitializer = (state, props, apiRef) => {\n  apiRef.current.unstable_caches.rows = createRowsInternalCache({\n    rows: props.rows,\n    getRowId: props.getRowId,\n    loading: props.loading\n  });\n  return _extends({}, state, {\n    rows: getRowsStateFromCache({\n      apiRef,\n      previousTree: null,\n      rowCountProp: props.rowCount,\n      loadingProp: props.loading\n    })\n  });\n};\nexport const useGridRows = (apiRef, props) => {\n  if (process.env.NODE_ENV !== 'production') {\n    // Freeze rows for immutability\n    Object.freeze(props.rows);\n  }\n  const logger = useGridLogger(apiRef, 'useGridRows');\n  const currentPage = useGridVisibleRows(apiRef, props);\n  const lastUpdateMs = React.useRef(Date.now());\n  const timeout = React.useRef(null);\n  const getRow = React.useCallback(id => {\n    var _ref;\n    return (_ref = gridRowsLookupSelector(apiRef)[id]) != null ? _ref : null;\n  }, [apiRef]);\n  const lookup = React.useMemo(() => currentPage.rows.reduce((acc, _ref2, index) => {\n    let {\n      id\n    } = _ref2;\n    acc[id] = index;\n    return acc;\n  }, {}), [currentPage.rows]);\n  const throttledRowsChange = React.useCallback((newCache, throttle) => {\n    const run = () => {\n      timeout.current = null;\n      lastUpdateMs.current = Date.now();\n      apiRef.current.setState(state => _extends({}, state, {\n        rows: getRowsStateFromCache({\n          apiRef,\n          previousTree: gridRowTreeSelector(apiRef),\n          rowCountProp: props.rowCount,\n          loadingProp: props.loading\n        })\n      }));\n      apiRef.current.publishEvent('rowsSet');\n      apiRef.current.forceUpdate();\n    };\n    if (timeout.current) {\n      clearTimeout(timeout.current);\n      timeout.current = null;\n    }\n    apiRef.current.unstable_caches.rows = newCache;\n    if (!throttle) {\n      run();\n      return;\n    }\n    const throttleRemainingTimeMs = props.throttleRowsMs - (Date.now() - lastUpdateMs.current);\n    if (throttleRemainingTimeMs > 0) {\n      timeout.current = setTimeout(run, throttleRemainingTimeMs);\n      return;\n    }\n    run();\n  }, [props.throttleRowsMs, props.rowCount, props.loading, apiRef]);\n  /**\n   * API METHODS\n   */\n\n  const setRows = React.useCallback(rows => {\n    logger.debug(`Updating all rows, new length ${rows.length}`);\n    throttledRowsChange(createRowsInternalCache({\n      rows,\n      getRowId: props.getRowId,\n      loading: props.loading\n    }), true);\n  }, [logger, props.getRowId, props.loading, throttledRowsChange]);\n  const updateRows = React.useCallback(updates => {\n    if (props.signature === GridSignature.DataGrid && updates.length > 1) {\n      // TODO: Add test with direct call to `apiRef.current.updateRows` in DataGrid after enabling the `apiRef` on the free plan.\n      throw new Error([\"MUI: You can't update several rows at once in `apiRef.current.updateRows` on the DataGrid.\", 'You need to upgrade to DataGridPro or DataGridPremium component to unlock this feature.'].join('\\n'));\n    } // we remove duplicate updates. A server can batch updates, and send several updates for the same row in one fn call.\n\n    const uniqUpdates = new Map();\n    updates.forEach(update => {\n      const id = getRowIdFromRowModel(update, props.getRowId, 'A row was provided without id when calling updateRows():');\n      if (uniqUpdates.has(id)) {\n        uniqUpdates.set(id, _extends({}, uniqUpdates.get(id), update));\n      } else {\n        uniqUpdates.set(id, update);\n      }\n    });\n    const deletedRowIds = [];\n    const prevCache = apiRef.current.unstable_caches.rows;\n    const newCache = {\n      rowsBeforePartialUpdates: prevCache.rowsBeforePartialUpdates,\n      loadingPropBeforePartialUpdates: prevCache.loadingPropBeforePartialUpdates,\n      idRowsLookup: _extends({}, prevCache.idRowsLookup),\n      idToIdLookup: _extends({}, prevCache.idToIdLookup),\n      ids: [...prevCache.ids]\n    };\n    uniqUpdates.forEach((partialRow, id) => {\n      // eslint-disable-next-line no-underscore-dangle\n      if (partialRow._action === 'delete') {\n        delete newCache.idRowsLookup[id];\n        delete newCache.idToIdLookup[id];\n        deletedRowIds.push(id);\n        return;\n      }\n      const oldRow = apiRef.current.getRow(id);\n      if (!oldRow) {\n        newCache.idRowsLookup[id] = partialRow;\n        newCache.idToIdLookup[id] = id;\n        newCache.ids.push(id);\n        return;\n      }\n      newCache.idRowsLookup[id] = _extends({}, apiRef.current.getRow(id), partialRow);\n    });\n    if (deletedRowIds.length > 0) {\n      newCache.ids = newCache.ids.filter(id => !deletedRowIds.includes(id));\n    }\n    throttledRowsChange(newCache, true);\n  }, [props.signature, props.getRowId, throttledRowsChange, apiRef]);\n  const getRowModels = React.useCallback(() => {\n    const allRows = gridRowIdsSelector(apiRef);\n    const idRowsLookup = gridRowsLookupSelector(apiRef);\n    return new Map(allRows.map(id => [id, idRowsLookup[id]]));\n  }, [apiRef]);\n  const getRowsCount = React.useCallback(() => gridRowCountSelector(apiRef), [apiRef]);\n  const getAllRowIds = React.useCallback(() => gridRowIdsSelector(apiRef), [apiRef]);\n  const getRowIndexRelativeToVisibleRows = React.useCallback(id => lookup[id], [lookup]);\n  const setRowChildrenExpansion = React.useCallback((id, isExpanded) => {\n    const currentNode = apiRef.current.getRowNode(id);\n    if (!currentNode) {\n      throw new Error(`MUI: No row with id #${id} found`);\n    }\n    const newNode = _extends({}, currentNode, {\n      childrenExpanded: isExpanded\n    });\n    apiRef.current.setState(state => {\n      return _extends({}, state, {\n        rows: _extends({}, state.rows, {\n          tree: _extends({}, state.rows.tree, {\n            [id]: newNode\n          })\n        })\n      });\n    });\n    apiRef.current.forceUpdate();\n    apiRef.current.publishEvent('rowExpansionChange', newNode);\n  }, [apiRef]);\n  const getRowNode = React.useCallback(id => {\n    var _gridRowTreeSelector$;\n    return (_gridRowTreeSelector$ = gridRowTreeSelector(apiRef)[id]) != null ? _gridRowTreeSelector$ : null;\n  }, [apiRef]);\n  const getRowGroupChildren = React.useCallback(_ref3 => {\n    let {\n      skipAutoGeneratedRows = true,\n      groupId,\n      applySorting,\n      applyFiltering\n    } = _ref3;\n    const tree = gridRowTreeSelector(apiRef);\n    let children;\n    if (applySorting) {\n      const groupNode = tree[groupId];\n      if (!groupNode) {\n        return [];\n      }\n      const sortedRowIds = gridSortedRowIdsSelector(apiRef);\n      children = [];\n      const startIndex = sortedRowIds.findIndex(id => id === groupId) + 1;\n      for (let index = startIndex; index < sortedRowIds.length && tree[sortedRowIds[index]].depth > groupNode.depth; index += 1) {\n        const id = sortedRowIds[index];\n        const node = tree[id];\n        if (!skipAutoGeneratedRows || !node.isAutoGenerated) {\n          children.push(id);\n        }\n      }\n    } else {\n      children = getTreeNodeDescendants(tree, groupId, skipAutoGeneratedRows);\n    }\n    if (applyFiltering) {\n      const filteredRowsLookup = gridFilteredRowsLookupSelector(apiRef);\n      children = children.filter(childId => filteredRowsLookup[childId] !== false);\n    }\n    return children;\n  }, [apiRef]);\n  const setRowIndex = React.useCallback((rowId, targetIndex) => {\n    const allRows = gridRowIdsSelector(apiRef);\n    const oldIndex = allRows.findIndex(row => row === rowId);\n    if (oldIndex === -1 || oldIndex === targetIndex) {\n      return;\n    }\n    logger.debug(`Moving row ${rowId} to index ${targetIndex}`);\n    const updatedRows = [...allRows];\n    updatedRows.splice(targetIndex, 0, updatedRows.splice(oldIndex, 1)[0]);\n    apiRef.current.setState(state => _extends({}, state, {\n      rows: _extends({}, state.rows, {\n        ids: updatedRows\n      })\n    }));\n    apiRef.current.applySorting();\n  }, [apiRef, logger]);\n  const rowApi = {\n    getRow,\n    getRowModels,\n    getRowsCount,\n    getAllRowIds,\n    setRows,\n    setRowIndex,\n    updateRows,\n    setRowChildrenExpansion,\n    getRowNode,\n    getRowIndexRelativeToVisibleRows,\n    getRowGroupChildren\n  };\n  /**\n   * EVENTS\n   */\n\n  const groupRows = React.useCallback(() => {\n    logger.info(`Row grouping pre-processing have changed, regenerating the row tree`);\n    let cache;\n    if (apiRef.current.unstable_caches.rows.rowsBeforePartialUpdates === props.rows) {\n      // The `props.rows` did not change since the last row grouping\n      // We can use the current rows cache which contains the partial updates done recently.\n      cache = apiRef.current.unstable_caches.rows;\n    } else {\n      // The `props.rows` has changed since the last row grouping\n      // We must use the new `props.rows` on the new grouping\n      // This occurs because this event is triggered before the `useEffect` on the rows when both the grouping pre-processing and the rows changes on the same render\n      cache = createRowsInternalCache({\n        rows: props.rows,\n        getRowId: props.getRowId,\n        loading: props.loading\n      });\n    }\n    throttledRowsChange(cache, false);\n  }, [logger, apiRef, props.rows, props.getRowId, props.loading, throttledRowsChange]);\n  const handleStrategyProcessorChange = React.useCallback(methodName => {\n    if (methodName === 'rowTreeCreation') {\n      groupRows();\n    }\n  }, [groupRows]);\n  const handleStrategyActivityChange = React.useCallback(() => {\n    // `rowTreeCreation` is the only processor ran when `strategyAvailabilityChange` is fired.\n    // All the other processors listen to `rowsSet` which will be published by the `groupRows` method below.\n    if (apiRef.current.unstable_getActiveStrategy('rowTree') !== gridRowGroupingNameSelector(apiRef)) {\n      groupRows();\n    }\n  }, [apiRef, groupRows]);\n  useGridApiEventHandler(apiRef, 'activeStrategyProcessorChange', handleStrategyProcessorChange);\n  useGridApiEventHandler(apiRef, 'strategyAvailabilityChange', handleStrategyActivityChange);\n  /**\n   * APPLIERS\n   */\n\n  const applyHydrateRowsProcessor = React.useCallback(() => {\n    apiRef.current.setState(state => _extends({}, state, {\n      rows: _extends({}, state.rows, apiRef.current.unstable_applyPipeProcessors('hydrateRows', state.rows.groupingResponseBeforeRowHydration))\n    }));\n    apiRef.current.publishEvent('rowsSet');\n    apiRef.current.forceUpdate();\n  }, [apiRef]);\n  useGridRegisterPipeApplier(apiRef, 'hydrateRows', applyHydrateRowsProcessor);\n  useGridApiMethod(apiRef, rowApi, 'GridRowApi');\n  /**\n   * EFFECTS\n   */\n\n  React.useEffect(() => {\n    return () => {\n      if (timeout.current !== null) {\n        clearTimeout(timeout.current);\n      }\n    };\n  }, []); // The effect do not track any value defined synchronously during the 1st render by hooks called after `useGridRows`\n  // As a consequence, the state generated by the 1st run of this useEffect will always be equal to the initialization one\n\n  const isFirstRender = React.useRef(true);\n  React.useEffect(() => {\n    if (isFirstRender.current) {\n      isFirstRender.current = false;\n      return;\n    }\n    const areNewRowsAlreadyInState = apiRef.current.unstable_caches.rows.rowsBeforePartialUpdates === props.rows;\n    const isNewLoadingAlreadyInState = apiRef.current.unstable_caches.rows.loadingPropBeforePartialUpdates === props.loading; // The new rows have already been applied (most likely in the `'rowGroupsPreProcessingChange'` listener)\n\n    if (areNewRowsAlreadyInState) {\n      // If the loading prop has changed, we need to update its value in the state because it won't be done by `throttledRowsChange`\n      if (!isNewLoadingAlreadyInState) {\n        apiRef.current.setState(state => _extends({}, state, {\n          rows: _extends({}, state.rows, {\n            loading: props.loading\n          })\n        }));\n        apiRef.current.unstable_caches.rows.loadingPropBeforePartialUpdates = props.loading;\n        apiRef.current.forceUpdate();\n      }\n      return;\n    }\n    logger.debug(`Updating all rows, new length ${props.rows.length}`);\n    throttledRowsChange(createRowsInternalCache({\n      rows: props.rows,\n      getRowId: props.getRowId,\n      loading: props.loading\n    }), false);\n  }, [props.rows, props.rowCount, props.getRowId, props.loading, logger, throttledRowsChange, apiRef]);\n};","map":{"version":3,"names":["_extends","React","useGridApiMethod","useGridLogger","gridRowCountSelector","gridRowsLookupSelector","gridRowTreeSelector","gridRowIdsSelector","gridRowGroupingNameSelector","GridSignature","useGridApiEventHandler","useGridVisibleRows","gridSortedRowIdsSelector","gridFilteredRowsLookupSelector","getTreeNodeDescendants","createRowsInternalCache","getRowsStateFromCache","getRowIdFromRowModel","useGridRegisterPipeApplier","rowsStateInitializer","state","props","apiRef","current","unstable_caches","rows","getRowId","loading","previousTree","rowCountProp","rowCount","loadingProp","useGridRows","process","env","NODE_ENV","Object","freeze","logger","currentPage","lastUpdateMs","useRef","Date","now","timeout","getRow","useCallback","id","_ref","lookup","useMemo","reduce","acc","index","throttledRowsChange","newCache","throttle","run","setState","publishEvent","forceUpdate","clearTimeout","throttleRemainingTimeMs","throttleRowsMs","setTimeout","setRows","debug","length","updateRows","updates","signature","DataGrid","Error","join","uniqUpdates","Map","forEach","update","has","set","get","deletedRowIds","prevCache","rowsBeforePartialUpdates","loadingPropBeforePartialUpdates","idRowsLookup","idToIdLookup","ids","partialRow","_action","push","oldRow","filter","includes","getRowModels","allRows","map","getRowsCount","getAllRowIds","getRowIndexRelativeToVisibleRows","setRowChildrenExpansion","isExpanded","currentNode","getRowNode","newNode","childrenExpanded","tree","_gridRowTreeSelector$","getRowGroupChildren","skipAutoGeneratedRows","groupId","applySorting","applyFiltering","children","groupNode","sortedRowIds","startIndex","findIndex","depth","node","isAutoGenerated","filteredRowsLookup","childId","setRowIndex","rowId","targetIndex","oldIndex","row","updatedRows","splice","rowApi","groupRows","info","cache","handleStrategyProcessorChange","methodName","handleStrategyActivityChange","unstable_getActiveStrategy","applyHydrateRowsProcessor","unstable_applyPipeProcessors","groupingResponseBeforeRowHydration","useEffect","isFirstRender","areNewRowsAlreadyInState","isNewLoadingAlreadyInState"],"sources":["/Users/user/node_modules/@mui/x-data-grid/hooks/features/rows/useGridRows.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridLogger } from '../../utils/useGridLogger';\nimport { gridRowCountSelector, gridRowsLookupSelector, gridRowTreeSelector, gridRowIdsSelector, gridRowGroupingNameSelector } from './gridRowsSelector';\nimport { GridSignature, useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { gridSortedRowIdsSelector } from '../sorting/gridSortingSelector';\nimport { gridFilteredRowsLookupSelector } from '../filter/gridFilterSelector';\nimport { getTreeNodeDescendants, createRowsInternalCache, getRowsStateFromCache, getRowIdFromRowModel } from './gridRowsUtils';\nimport { useGridRegisterPipeApplier } from '../../core/pipeProcessing';\nexport const rowsStateInitializer = (state, props, apiRef) => {\n  apiRef.current.unstable_caches.rows = createRowsInternalCache({\n    rows: props.rows,\n    getRowId: props.getRowId,\n    loading: props.loading\n  });\n  return _extends({}, state, {\n    rows: getRowsStateFromCache({\n      apiRef,\n      previousTree: null,\n      rowCountProp: props.rowCount,\n      loadingProp: props.loading\n    })\n  });\n};\nexport const useGridRows = (apiRef, props) => {\n  if (process.env.NODE_ENV !== 'production') {\n    // Freeze rows for immutability\n    Object.freeze(props.rows);\n  }\n\n  const logger = useGridLogger(apiRef, 'useGridRows');\n  const currentPage = useGridVisibleRows(apiRef, props);\n  const lastUpdateMs = React.useRef(Date.now());\n  const timeout = React.useRef(null);\n  const getRow = React.useCallback(id => {\n    var _ref;\n\n    return (_ref = gridRowsLookupSelector(apiRef)[id]) != null ? _ref : null;\n  }, [apiRef]);\n  const lookup = React.useMemo(() => currentPage.rows.reduce((acc, {\n    id\n  }, index) => {\n    acc[id] = index;\n    return acc;\n  }, {}), [currentPage.rows]);\n  const throttledRowsChange = React.useCallback((newCache, throttle) => {\n    const run = () => {\n      timeout.current = null;\n      lastUpdateMs.current = Date.now();\n      apiRef.current.setState(state => _extends({}, state, {\n        rows: getRowsStateFromCache({\n          apiRef,\n          previousTree: gridRowTreeSelector(apiRef),\n          rowCountProp: props.rowCount,\n          loadingProp: props.loading\n        })\n      }));\n      apiRef.current.publishEvent('rowsSet');\n      apiRef.current.forceUpdate();\n    };\n\n    if (timeout.current) {\n      clearTimeout(timeout.current);\n      timeout.current = null;\n    }\n\n    apiRef.current.unstable_caches.rows = newCache;\n\n    if (!throttle) {\n      run();\n      return;\n    }\n\n    const throttleRemainingTimeMs = props.throttleRowsMs - (Date.now() - lastUpdateMs.current);\n\n    if (throttleRemainingTimeMs > 0) {\n      timeout.current = setTimeout(run, throttleRemainingTimeMs);\n      return;\n    }\n\n    run();\n  }, [props.throttleRowsMs, props.rowCount, props.loading, apiRef]);\n  /**\n   * API METHODS\n   */\n\n  const setRows = React.useCallback(rows => {\n    logger.debug(`Updating all rows, new length ${rows.length}`);\n    throttledRowsChange(createRowsInternalCache({\n      rows,\n      getRowId: props.getRowId,\n      loading: props.loading\n    }), true);\n  }, [logger, props.getRowId, props.loading, throttledRowsChange]);\n  const updateRows = React.useCallback(updates => {\n    if (props.signature === GridSignature.DataGrid && updates.length > 1) {\n      // TODO: Add test with direct call to `apiRef.current.updateRows` in DataGrid after enabling the `apiRef` on the free plan.\n      throw new Error([\"MUI: You can't update several rows at once in `apiRef.current.updateRows` on the DataGrid.\", 'You need to upgrade to DataGridPro or DataGridPremium component to unlock this feature.'].join('\\n'));\n    } // we remove duplicate updates. A server can batch updates, and send several updates for the same row in one fn call.\n\n\n    const uniqUpdates = new Map();\n    updates.forEach(update => {\n      const id = getRowIdFromRowModel(update, props.getRowId, 'A row was provided without id when calling updateRows():');\n\n      if (uniqUpdates.has(id)) {\n        uniqUpdates.set(id, _extends({}, uniqUpdates.get(id), update));\n      } else {\n        uniqUpdates.set(id, update);\n      }\n    });\n    const deletedRowIds = [];\n    const prevCache = apiRef.current.unstable_caches.rows;\n    const newCache = {\n      rowsBeforePartialUpdates: prevCache.rowsBeforePartialUpdates,\n      loadingPropBeforePartialUpdates: prevCache.loadingPropBeforePartialUpdates,\n      idRowsLookup: _extends({}, prevCache.idRowsLookup),\n      idToIdLookup: _extends({}, prevCache.idToIdLookup),\n      ids: [...prevCache.ids]\n    };\n    uniqUpdates.forEach((partialRow, id) => {\n      // eslint-disable-next-line no-underscore-dangle\n      if (partialRow._action === 'delete') {\n        delete newCache.idRowsLookup[id];\n        delete newCache.idToIdLookup[id];\n        deletedRowIds.push(id);\n        return;\n      }\n\n      const oldRow = apiRef.current.getRow(id);\n\n      if (!oldRow) {\n        newCache.idRowsLookup[id] = partialRow;\n        newCache.idToIdLookup[id] = id;\n        newCache.ids.push(id);\n        return;\n      }\n\n      newCache.idRowsLookup[id] = _extends({}, apiRef.current.getRow(id), partialRow);\n    });\n\n    if (deletedRowIds.length > 0) {\n      newCache.ids = newCache.ids.filter(id => !deletedRowIds.includes(id));\n    }\n\n    throttledRowsChange(newCache, true);\n  }, [props.signature, props.getRowId, throttledRowsChange, apiRef]);\n  const getRowModels = React.useCallback(() => {\n    const allRows = gridRowIdsSelector(apiRef);\n    const idRowsLookup = gridRowsLookupSelector(apiRef);\n    return new Map(allRows.map(id => [id, idRowsLookup[id]]));\n  }, [apiRef]);\n  const getRowsCount = React.useCallback(() => gridRowCountSelector(apiRef), [apiRef]);\n  const getAllRowIds = React.useCallback(() => gridRowIdsSelector(apiRef), [apiRef]);\n  const getRowIndexRelativeToVisibleRows = React.useCallback(id => lookup[id], [lookup]);\n  const setRowChildrenExpansion = React.useCallback((id, isExpanded) => {\n    const currentNode = apiRef.current.getRowNode(id);\n\n    if (!currentNode) {\n      throw new Error(`MUI: No row with id #${id} found`);\n    }\n\n    const newNode = _extends({}, currentNode, {\n      childrenExpanded: isExpanded\n    });\n\n    apiRef.current.setState(state => {\n      return _extends({}, state, {\n        rows: _extends({}, state.rows, {\n          tree: _extends({}, state.rows.tree, {\n            [id]: newNode\n          })\n        })\n      });\n    });\n    apiRef.current.forceUpdate();\n    apiRef.current.publishEvent('rowExpansionChange', newNode);\n  }, [apiRef]);\n  const getRowNode = React.useCallback(id => {\n    var _gridRowTreeSelector$;\n\n    return (_gridRowTreeSelector$ = gridRowTreeSelector(apiRef)[id]) != null ? _gridRowTreeSelector$ : null;\n  }, [apiRef]);\n  const getRowGroupChildren = React.useCallback(({\n    skipAutoGeneratedRows = true,\n    groupId,\n    applySorting,\n    applyFiltering\n  }) => {\n    const tree = gridRowTreeSelector(apiRef);\n    let children;\n\n    if (applySorting) {\n      const groupNode = tree[groupId];\n\n      if (!groupNode) {\n        return [];\n      }\n\n      const sortedRowIds = gridSortedRowIdsSelector(apiRef);\n      children = [];\n      const startIndex = sortedRowIds.findIndex(id => id === groupId) + 1;\n\n      for (let index = startIndex; index < sortedRowIds.length && tree[sortedRowIds[index]].depth > groupNode.depth; index += 1) {\n        const id = sortedRowIds[index];\n        const node = tree[id];\n\n        if (!skipAutoGeneratedRows || !node.isAutoGenerated) {\n          children.push(id);\n        }\n      }\n    } else {\n      children = getTreeNodeDescendants(tree, groupId, skipAutoGeneratedRows);\n    }\n\n    if (applyFiltering) {\n      const filteredRowsLookup = gridFilteredRowsLookupSelector(apiRef);\n      children = children.filter(childId => filteredRowsLookup[childId] !== false);\n    }\n\n    return children;\n  }, [apiRef]);\n  const setRowIndex = React.useCallback((rowId, targetIndex) => {\n    const allRows = gridRowIdsSelector(apiRef);\n    const oldIndex = allRows.findIndex(row => row === rowId);\n\n    if (oldIndex === -1 || oldIndex === targetIndex) {\n      return;\n    }\n\n    logger.debug(`Moving row ${rowId} to index ${targetIndex}`);\n    const updatedRows = [...allRows];\n    updatedRows.splice(targetIndex, 0, updatedRows.splice(oldIndex, 1)[0]);\n    apiRef.current.setState(state => _extends({}, state, {\n      rows: _extends({}, state.rows, {\n        ids: updatedRows\n      })\n    }));\n    apiRef.current.applySorting();\n  }, [apiRef, logger]);\n  const rowApi = {\n    getRow,\n    getRowModels,\n    getRowsCount,\n    getAllRowIds,\n    setRows,\n    setRowIndex,\n    updateRows,\n    setRowChildrenExpansion,\n    getRowNode,\n    getRowIndexRelativeToVisibleRows,\n    getRowGroupChildren\n  };\n  /**\n   * EVENTS\n   */\n\n  const groupRows = React.useCallback(() => {\n    logger.info(`Row grouping pre-processing have changed, regenerating the row tree`);\n    let cache;\n\n    if (apiRef.current.unstable_caches.rows.rowsBeforePartialUpdates === props.rows) {\n      // The `props.rows` did not change since the last row grouping\n      // We can use the current rows cache which contains the partial updates done recently.\n      cache = apiRef.current.unstable_caches.rows;\n    } else {\n      // The `props.rows` has changed since the last row grouping\n      // We must use the new `props.rows` on the new grouping\n      // This occurs because this event is triggered before the `useEffect` on the rows when both the grouping pre-processing and the rows changes on the same render\n      cache = createRowsInternalCache({\n        rows: props.rows,\n        getRowId: props.getRowId,\n        loading: props.loading\n      });\n    }\n\n    throttledRowsChange(cache, false);\n  }, [logger, apiRef, props.rows, props.getRowId, props.loading, throttledRowsChange]);\n  const handleStrategyProcessorChange = React.useCallback(methodName => {\n    if (methodName === 'rowTreeCreation') {\n      groupRows();\n    }\n  }, [groupRows]);\n  const handleStrategyActivityChange = React.useCallback(() => {\n    // `rowTreeCreation` is the only processor ran when `strategyAvailabilityChange` is fired.\n    // All the other processors listen to `rowsSet` which will be published by the `groupRows` method below.\n    if (apiRef.current.unstable_getActiveStrategy('rowTree') !== gridRowGroupingNameSelector(apiRef)) {\n      groupRows();\n    }\n  }, [apiRef, groupRows]);\n  useGridApiEventHandler(apiRef, 'activeStrategyProcessorChange', handleStrategyProcessorChange);\n  useGridApiEventHandler(apiRef, 'strategyAvailabilityChange', handleStrategyActivityChange);\n  /**\n   * APPLIERS\n   */\n\n  const applyHydrateRowsProcessor = React.useCallback(() => {\n    apiRef.current.setState(state => _extends({}, state, {\n      rows: _extends({}, state.rows, apiRef.current.unstable_applyPipeProcessors('hydrateRows', state.rows.groupingResponseBeforeRowHydration))\n    }));\n    apiRef.current.publishEvent('rowsSet');\n    apiRef.current.forceUpdate();\n  }, [apiRef]);\n  useGridRegisterPipeApplier(apiRef, 'hydrateRows', applyHydrateRowsProcessor);\n  useGridApiMethod(apiRef, rowApi, 'GridRowApi');\n  /**\n   * EFFECTS\n   */\n\n  React.useEffect(() => {\n    return () => {\n      if (timeout.current !== null) {\n        clearTimeout(timeout.current);\n      }\n    };\n  }, []); // The effect do not track any value defined synchronously during the 1st render by hooks called after `useGridRows`\n  // As a consequence, the state generated by the 1st run of this useEffect will always be equal to the initialization one\n\n  const isFirstRender = React.useRef(true);\n  React.useEffect(() => {\n    if (isFirstRender.current) {\n      isFirstRender.current = false;\n      return;\n    }\n\n    const areNewRowsAlreadyInState = apiRef.current.unstable_caches.rows.rowsBeforePartialUpdates === props.rows;\n    const isNewLoadingAlreadyInState = apiRef.current.unstable_caches.rows.loadingPropBeforePartialUpdates === props.loading; // The new rows have already been applied (most likely in the `'rowGroupsPreProcessingChange'` listener)\n\n    if (areNewRowsAlreadyInState) {\n      // If the loading prop has changed, we need to update its value in the state because it won't be done by `throttledRowsChange`\n      if (!isNewLoadingAlreadyInState) {\n        apiRef.current.setState(state => _extends({}, state, {\n          rows: _extends({}, state.rows, {\n            loading: props.loading\n          })\n        }));\n        apiRef.current.unstable_caches.rows.loadingPropBeforePartialUpdates = props.loading;\n        apiRef.current.forceUpdate();\n      }\n\n      return;\n    }\n\n    logger.debug(`Updating all rows, new length ${props.rows.length}`);\n    throttledRowsChange(createRowsInternalCache({\n      rows: props.rows,\n      getRowId: props.getRowId,\n      loading: props.loading\n    }), false);\n  }, [props.rows, props.rowCount, props.getRowId, props.loading, logger, throttledRowsChange, apiRef]);\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}